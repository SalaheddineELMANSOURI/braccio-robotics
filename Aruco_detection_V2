#!/usr/bin/env python
# %%

import time
import cv2 # Import the OpenCV library
import numpy as np # Import Numpy library
from ArucoDetection_definitions import *
import braccio_control_python #control braccio
import keyboard
from tkinter import *
from PIL import ImageTk, Image, ImageDraw
from datetime import *
import time

class Dashboard2:
    def __init__(self, window, inc):
        self.window = window
        self.inc = inc
        self.window.title("Robot Pick and Place")
        self.window.geometry("1366x768")
        self.window.resizable(0, 0)
        self.window.state('zoomed')
        self.window.config(background='#eff5f6')
        icon = PhotoImage(file='images\\pic-icon.png')
        self.window.iconphoto(True, icon)

        self.header = Frame(self.window, bg='#009df4')
        self.header.place(x=300, y=0, width=1070, height=60)

        self.sidebar = Frame(self.window, bg='#ffffff')
        self.sidebar.place(x=0, y=0, width=300, height=750)

        self.heading = Label(self.window, text='Dashboard', font=("", 15, "bold"), fg='#0064d3', bg='#eff5f6')
        self.heading.place(x=325, y=70)

        self.bodyFrame2 = Frame(self.window, bg='#009aa5')
        self.bodyFrame2.place(x=328, y=110, width=310, height=220)

        self.bodyFrame3 = Frame(self.window, bg='#e21f26')
        self.bodyFrame3.place(x=680, y=110, width=310, height=220)

        self.bodyFrame4 = Frame(self.window, bg='#ffcb1f')
        self.bodyFrame4.place(x=1030, y=110, width=310, height=220)

        self.logoImage = ImageTk.PhotoImage(file='images/hyy.png')
        self.logo = Label(self.sidebar, image=self.logoImage, bg='#ffffff')
        self.logo.place(x=70, y=80)

        self.brandName = Label(self.sidebar, text='My Robot', bg='#ffffff', font=("", 15, "bold"))
        self.brandName.place(x=95, y=200)

        self.ExitImage = ImageTk.PhotoImage(file='images/exit-icon.png')
        self.Exit = Label(self.sidebar, image=self.ExitImage, bg='#ffffff')
        self.Exit.place(x=35, y=273)

        self.Exit_text = Button(self.sidebar, text="Exit", bg='#ffffff', font=("", 13, "bold"), bd=0,
                                cursor='hand2', activebackground='#ffffff', command=window.destroy)
        self.Exit_text.place(x=80, y=287)

        self.total_people = Label(self.bodyFrame2, text='230', bg='#009aa5', font=("", 25, "bold"))
        self.total_people.place(x=120, y=100)

        self.totalPeople = Label(self.bodyFrame2, bg='#009aa5')
        self.totalPeople.place(x=220, y=0)

        self.totalPeople_label = Label(self.bodyFrame2, text="Time", bg='#009aa5', font=("", 12, "bold"),
                                       fg='white')
        self.totalPeople_label.place(x=45, y=25)

        self.people_left = Label(self.bodyFrame3, text=self.inc , bg='#e21f26', font=("", 25, "bold"))
        self.people_left.place(x=120, y=100)

        self.Left = Label(self.bodyFrame3,  bg='#e21f26')
        self.Left.place(x=220, y=0)

        self.peopleLeft_label = Label(self.bodyFrame3, text="Pick Counter", bg='#e21f26', font=("", 12, "bold"),
                                      fg='white')
        self.peopleLeft_label.place(x=45, y=25)

        self.total_earnings = Label(self.bodyFrame4, text='$40,000.00', bg='#ffcb1f', font=("", 25, "bold"))
        self.total_earnings.place(x=80, y=100)

        self.earnings_label = Label(self.bodyFrame4, text="Total Earnings", bg='#ffcb1f', font=("", 12, "bold"),
                                    fg='white')
        self.earnings_label.place(x=5, y=5)
        self.earningsIcon_image = ImageTk.PhotoImage(file='images/earn3.png')
        self.earningsIcon = Label(self.bodyFrame4, image=self.earningsIcon_image, bg='#ffcb1f')
        self.earningsIcon.place(x=220, y=0)




        self.clock_image = ImageTk.PhotoImage(file="images/time.png")
        self.date_time_image = Label(self.bodyFrame2, image=self.clock_image, bg="#009aa5")
        self.date_time_image.place(x=15, y=25)

        self.date_time = Label(self.bodyFrame2, bg="#009aa5")
        self.date_time.place(x=120, y=100)
        self.show_time()

    def show_time(self):
        self.time = time.strftime("%H:%M:%S")
        self.date = time.strftime('%Y/%m/%d')
        set_text = f"  {self.time} \n {self.date}"
        self.date_time.configure(text=set_text, font=("", 13, "bold"), bd=0, bg="white", fg="black")
        self.date_time.after(100, self.show_time)



start_time = time.time()
increment = 0
desired_aruco_dictionary1 = "DICT_4X4_50"
desired_aruco_dictionary2 = "DICT_6X6_50"

# The different ArUco dictionaries built into the OpenCV library. 
ARUCO_DICT = {
  "DICT_4X4_50": cv2.aruco.DICT_4X4_50,
  "DICT_4X4_100": cv2.aruco.DICT_4X4_100,
  "DICT_4X4_250": cv2.aruco.DICT_4X4_250,
  "DICT_4X4_1000": cv2.aruco.DICT_4X4_1000,
  "DICT_5X5_50": cv2.aruco.DICT_5X5_50,
  "DICT_5X5_100": cv2.aruco.DICT_5X5_100,
  "DICT_5X5_250": cv2.aruco.DICT_5X5_250,
  "DICT_5X5_1000": cv2.aruco.DICT_5X5_1000,
  "DICT_6X6_50": cv2.aruco.DICT_6X6_50,
  "DICT_6X6_100": cv2.aruco.DICT_6X6_100,
  "DICT_6X6_250": cv2.aruco.DICT_6X6_250,
  "DICT_6X6_1000": cv2.aruco.DICT_6X6_1000,
  "DICT_7X7_50": cv2.aruco.DICT_7X7_50,
  "DICT_7X7_100": cv2.aruco.DICT_7X7_100,
  "DICT_7X7_250": cv2.aruco.DICT_7X7_250,
  "DICT_7X7_1000": cv2.aruco.DICT_7X7_1000,
  "DICT_ARUCO_ORIGINAL": cv2.aruco.DICT_ARUCO_ORIGINAL
}


def get_markers(vid_frame, aruco_dictionary, aruco_parameters):
    bboxs, ids, rejected = cv2.aruco.detectMarkers(vid_frame, aruco_dictionary, parameters=aruco_parameters)
    if ids is not None:
        ids_sorted=[]
        for id_number in ids:
            ids_sorted.append(id_number[0])
    else:
        ids_sorted=ids
    return bboxs,ids_sorted

#initial framesize of the cropped window
square_points=[[10,cv2.CAP_PROP_FRAME_HEIGHT-10], [cv2.CAP_PROP_FRAME_WIDTH-10,cv2.CAP_PROP_FRAME_HEIGHT-10], [cv2.CAP_PROP_FRAME_WIDTH-10, 10], [10,10]] #initial square

init_loc_1=[10,400]
init_loc_2=[400,400]
init_loc_3=[400,10]
init_loc_4=[10,10]

#initiaize locations
current_square_points=[init_loc_1,init_loc_2,init_loc_3,init_loc_4]
current_center_Corner=[[0,0]]


#use location hold
marker_location_hold=True

def main():
   
    # Load the ArUco dictionary
    print("[INFO] detecting '{}' markers...".format(desired_aruco_dictionary1))
    this_aruco_dictionary1 = cv2.aruco.getPredefinedDictionary(ARUCO_DICT[desired_aruco_dictionary1])   #for 4x4 markers
    this_aruco_parameters1 = cv2.aruco.DetectorParameters()  #for 4x4 markers
    this_aruco_dictionary2 = cv2.aruco.getPredefinedDictionary(ARUCO_DICT[desired_aruco_dictionary2])  #for 6x6 markers
    this_aruco_parameters2 = cv2.aruco.DetectorParameters()  #for 6x6 markers
    
    # Start the video stream
    # url = 'http://192.168.0.17:8080/videofeed'
    cap = cv2.VideoCapture(1)
    
    square_points=current_square_points


    while(True):

        current_time=time.time()
        delay=0 #seconds , set to zero if not an demo

        ret, frame = cap.read()  
        
        
        # Detect 4x4 ArUco markers in the video frame
        markers,ids=get_markers(frame, this_aruco_dictionary1, this_aruco_parameters1)

        #create copy of te initial 'clean frame'
        frame_clean=frame.copy()

        #get info over the different markers and display info
        left_corners,corner_ids=getMarkerCoordinates(markers,ids,0)


        #update the markers positions when a markers is found. When no marker is found, use previous location
        if marker_location_hold==True:
            if corner_ids is not None:
                count=0
                for id in corner_ids:
                    
                    if id>4:
                        break  #sometimes wring values are read
                    current_square_points[id-1]=left_corners[count]
                    count=count+1
            left_corners=current_square_points            
            corner_ids=[1,2,3,4]      

        
        if (start_time+delay*1)<current_time and (start_time+delay*2)>current_time:   
            cv2.aruco.drawDetectedMarkers(frame, markers) #built in open cv function
        if (start_time+delay*2)<current_time:    
            draw_corners(frame,left_corners)
        if (start_time+delay*3)<current_time:
            draw_numbers(frame,left_corners,corner_ids)
        if (start_time+delay*4)<current_time:    
            show_spec(frame,left_corners)
       
        frame_with_square,squareFound=draw_field(frame,left_corners,corner_ids)
        
            
        #####look for foam    
        #extract square and show in extra window
        if (start_time+delay*6)<current_time:
            if squareFound:
                square_points=left_corners
            img_wrapped=four_point_transform(frame_clean, np.array(square_points))
            # look for foam, Detect 6x6 ArUco markers in the video frame
            h, w, c = img_wrapped.shape
            marker_foam,ids_foam=get_markers(img_wrapped, this_aruco_dictionary2, this_aruco_parameters2)
            left_corner_foam,corner_id_foam=getMarkerCoordinates(marker_foam,ids_foam,0)
            centerCorner=getMarkerCenter_foam(marker_foam)
           
            #update the markers positions when a markers is found. When no marker is found, use previous location
            if marker_location_hold==True:
                if corner_id_foam is not None:
                    #only one piece of foam
                    
                    current_center_Corner[0]=centerCorner[0]
                centerCorner[0]=current_center_Corner[0]              
                
            
            
            
            
            draw_corners(img_wrapped,centerCorner)
            #draw cross over frame
            img_wrapped=cv2.line(img_wrapped,(centerCorner[0][0],0), (centerCorner[0][0],h), (0,0,255), 2)
            img_wrapped=cv2.line(img_wrapped,(0,(centerCorner[0][1])), (w,(centerCorner[0][1])), (0,0,255), 2)

            draw_numbers(img_wrapped,left_corner_foam,corner_id_foam)
            cv2.imshow('img_wrapped',img_wrapped)



        
        
        
        
        
        # Display the resulting frame
        cv2.imshow('frame_with_square',frame_with_square)
        #cv2.imshow('img_cropped',img_cropped)    
        # If "q" is pressed on the keyboard, 
        # exit this loop
        if cv2.waitKey(1) & 0xFF == ord('q'):
            braccio_control_python.arm.write(b'H0,90,20,90,90,73,20\n') 
            break
            
        
        # #pick up piece of foam    
        if keyboard.is_pressed('p'):
            increment+1
            x_coordinate=int((centerCorner[0][1]/h)*600)-300
            y_coordinate=int((centerCorner[0][0]/w)*300)
            print("Optical position: ",x_coordinate,", ",y_coordinate)
            # print(x_coordinate,y_coordinate)
            #camera compensation
            x_coordinate_comp,y_coordinate_comp=braccio_control_python.camera_compensation(x_coordinate,y_coordinate)
            print("Position after compensation: ",x_coordinate_comp,", ",y_coordinate_comp)
            # print(x_coordinate_comp,y_coordinate_comp)
            braccio_control_python.pick_up(x_coordinate,y_coordinate)
            print("Foam placed!")
            
    # Close down the video stream
    cap.release()
    cv2.destroyAllWindows()
    return centerCorner 
   
def wind():
    window = Tk()
    Dashboard2(window, increment)
    window.mainloop()

if __name__ == '__main__':
    braccio_control_python.home()
    wind()
    foam_center=main()  #pull foam location from markers

    
# %%
# %%
